# Database Migrations Guide

This guide covers setting up and using Flask-Migrate for production-ready database schema management.

## Overview

Flask-Migrate provides version control for your database schema using Alembic. It's the recommended approach for production environments where you need to preserve existing data during schema changes.

## Setup Flask-Migrate

### 1. Install Dependencies

Flask-Migrate is already in your `requirements.txt`. Install it:

```bash
pip install -r requirements.txt
```

### 2. Initialize Migration Repository

**One-time setup:**

```bash
# Set Flask app
export FLASK_APP=api.py

# Initialize migrations (creates migrations/ folder)
flask db init
```

This creates:
```
migrations/
├── alembic.ini
├── env.py
├── script.py.mako
└── versions/
```

### 3. Create Initial Migration

```bash
# Generate migration for current schema
flask db migrate -m "Initial migration"

# Apply the migration
flask db upgrade
```

## Migration Workflow

### Standard Process

1. **Make model changes** in `data_warehouse_models.py`
2. **Generate migration** from model changes
3. **Review migration** file
4. **Apply migration** to database

### Example: Adding Email to User

**Step 1: Modify Model**

```python
# In data_warehouse_models.py
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), nullable=False)
    email = db.Column(db.String(120), nullable=True, unique=True)  # NEW
```

**Step 2: Generate Migration**

```bash
flask db migrate -m "Add email column to User table"
```

**Step 3: Review Generated Migration**

Check `migrations/versions/xxx_add_email_column_to_user_table.py`:

```python
"""Add email column to User table

Revision ID: abc123def456
Revises: previous_revision
Create Date: 2024-10-26 14:30:22.123456

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = 'abc123def456'
down_revision = 'previous_revision'
branch_labels = None
depends_on = None

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.add_column(sa.Column('email', sa.String(length=120), nullable=True))
        batch_op.create_unique_constraint('uq_user_email', ['email'])
    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.drop_constraint('uq_user_email', type_='unique')
        batch_op.drop_column('email')
    # ### end Alembic commands ###
```

**Step 4: Apply Migration**

```bash
flask db upgrade
```

## Common Migration Scenarios

### 1. Adding a New Table

**Model Change:**
```python
class Address(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    user = db.relationship("User")
    street = db.Column(db.String(200), nullable=False)
    city = db.Column(db.String(100), nullable=False)
    state = db.Column(db.String(50), nullable=False)
    zip_code = db.Column(db.String(10), nullable=False)
```

**Commands:**
```bash
flask db migrate -m "Add Address table"
flask db upgrade
```

### 2. Modifying Column Properties

**Model Change:**
```python
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), nullable=False)  # Changed from 80 to 120
    email = db.Column(db.String(120), nullable=False)  # Changed from nullable=True
```

**Commands:**
```bash
flask db migrate -m "Increase name length and make email required"
flask db upgrade
```

### 3. Adding Indexes

**Model Change:**
```python
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(80), nullable=False, index=True)  # Add index
    email = db.Column(db.String(120), nullable=True, unique=True)
```

**Commands:**
```bash
flask db migrate -m "Add index to User name column"
flask db upgrade
```

### 4. Data Migrations

Sometimes you need to migrate existing data. Create a custom migration:

```bash
flask db revision -m "Populate email addresses for existing users"
```

Edit the generated migration file:

```python
def upgrade():
    # Import your models
    from data_warehouse_models import User, db
    
    # Update existing users
    users = User.query.filter(User.email.is_(None)).all()
    for user in users:
        user.email = f"{user.name.lower().replace(' ', '.')}@example.com"
    
    db.session.commit()

def downgrade():
    # Clear email addresses
    from data_warehouse_models import User, db
    
    User.query.update({User.email: None})
    db.session.commit()
```

## Migration Management Commands

### Using Flask CLI Directly

```bash
# Set environment
export FLASK_APP=api.py

# Create migration
flask db migrate -m "Description of changes"

# Apply migrations
flask db upgrade

# Rollback one migration
flask db downgrade

# Show migration history
flask db history

# Show current revision
flask db current

# Show pending migrations
flask db show

# Upgrade to specific revision
flask db upgrade abc123def456

# Downgrade to specific revision
flask db downgrade abc123def456
```

### Using the Management Script

Use the `manage_db.py` script for easier management:

```bash
# Initialize (one time)
python manage_db.py init-db

# Create migration
python manage_db.py create-migration

# Apply migrations
python manage_db.py apply-migrations

# Rollback
python manage_db.py rollback

# Show history
python manage_db.py migration-history

# Show current
python manage_db.py current-revision
```

## Advanced Migration Scenarios

### 1. Renaming Columns

Alembic doesn't auto-detect column renames. Create manual migration:

```bash
flask db revision -m "Rename user name to full_name"
```

```python
def upgrade():
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.alter_column('name', new_column_name='full_name')

def downgrade():
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.alter_column('full_name', new_column_name='name')
```

### 2. Renaming Tables

```bash
flask db revision -m "Rename paymenttransaction to payment"
```

```python
def upgrade():
    op.rename_table('paymenttransaction', 'payment')

def downgrade():
    op.rename_table('payment', 'paymenttransaction')
```

### 3. Complex Data Transformations

```bash
flask db revision -m "Split user name into first_name and last_name"
```

```python
def upgrade():
    # Add new columns
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.add_column(sa.Column('first_name', sa.String(50), nullable=True))
        batch_op.add_column(sa.Column('last_name', sa.String(50), nullable=True))
    
    # Migrate data
    connection = op.get_bind()
    result = connection.execute("SELECT id, name FROM user")
    for row in result:
        names = row.name.split(' ', 1)
        first_name = names[0]
        last_name = names[1] if len(names) > 1 else ''
        
        connection.execute(
            "UPDATE user SET first_name = ?, last_name = ? WHERE id = ?",
            (first_name, last_name, row.id)
        )
    
    # Remove old column
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.drop_column('name')

def downgrade():
    # Add back name column
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.add_column(sa.Column('name', sa.String(80), nullable=True))
    
    # Migrate data back
    connection = op.get_bind()
    result = connection.execute("SELECT id, first_name, last_name FROM user")
    for row in result:
        full_name = f"{row.first_name} {row.last_name}".strip()
        connection.execute(
            "UPDATE user SET name = ? WHERE id = ?",
            (full_name, row.id)
        )
    
    # Remove new columns
    with op.batch_alter_table('user', schema=None) as batch_op:
        batch_op.drop_column('last_name')
        batch_op.drop_column('first_name')
```

## Migration Best Practices

### 1. Review Before Applying

Always review generated migrations:

```bash
# Generate migration
flask db migrate -m "Add user preferences"

# Review the file in migrations/versions/
cat migrations/versions/xxx_add_user_preferences.py

# Apply only after review
flask db upgrade
```

### 2. Test Migrations

Create a test script:

```python
# test_migration.py
import os
import tempfile
from api import app, db

def test_migration():
    # Create temporary database
    with tempfile.NamedTemporaryFile(suffix='.db', delete=False) as tmp:
        test_db = tmp.name
    
    # Configure app for testing
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{test_db}'
    
    with app.app_context():
        # Apply migrations
        from flask_migrate import upgrade
        upgrade()
        
        # Test the schema
        from data_warehouse_models import User
        user = User(name="Test", email="test@example.com")
        db.session.add(user)
        db.session.commit()
        
        print("Migration test passed!")
    
    # Cleanup
    os.unlink(test_db)

if __name__ == "__main__":
    test_migration()
```

### 3. Backup Before Production Migrations

```bash
# Production migration workflow
python backup_db.py backup
flask db upgrade
```

### 4. Handle Migration Conflicts

If multiple developers create migrations:

```bash
# Merge migrations
flask db merge -m "Merge migrations" revision1 revision2

# Or rebase migrations
flask db downgrade base
flask db upgrade
```

## Troubleshooting Migrations

### 1. "Target database is not up to date"

```bash
# Check current revision
flask db current

# Check migration history
flask db history

# Upgrade to latest
flask db upgrade
```

### 2. "Can't locate revision"

```bash
# Stamp database with current revision
flask db stamp head

# Or stamp with specific revision
flask db stamp abc123def456
```

### 3. "Migration failed"

```bash
# Rollback to previous state
flask db downgrade

# Fix the migration file
# Then try again
flask db upgrade
```

### 4. Reset Migrations (Development Only)

```bash
# Remove migrations
rm -rf migrations/

# Remove migration table from database
sqlite3 data_warehouse.db "DROP TABLE IF EXISTS alembic_version;"

# Reinitialize
flask db init
flask db migrate -m "Initial migration"
flask db upgrade
```

## Production Deployment

### 1. Automated Deployment Script

Create `deploy.py`:

```python
#!/usr/bin/env python3
import os
import subprocess
import sys

def run_command(cmd):
    """Run command and exit on failure."""
    result = subprocess.run(cmd, shell=True)
    if result.returncode != 0:
        print(f"Command failed: {cmd}")
        sys.exit(1)

def deploy():
    """Deploy with migrations."""
    print("Starting deployment...")
    
    # Backup database
    print("Creating backup...")
    run_command("python backup_db.py backup")
    
    # Apply migrations
    print("Applying migrations...")
    run_command("flask db upgrade")
    
    # Restart application
    print("Restarting application...")
    # Add your restart commands here
    
    print("Deployment completed successfully!")

if __name__ == "__main__":
    deploy()
```

### 2. Health Check After Migration

```python
# health_check.py
from api import app, db
from data_warehouse_models import User, Quote, Policy, PaymentTransaction

def health_check():
    """Verify database health after migration."""
    with app.app_context():
        try:
            # Test each table
            user_count = User.query.count()
            quote_count = Quote.query.count()
            policy_count = Policy.query.count()
            payment_count = PaymentTransaction.query.count()
            
            print(f"✅ Users: {user_count}")
            print(f"✅ Quotes: {quote_count}")
            print(f"✅ Policies: {policy_count}")
            print(f"✅ Payments: {payment_count}")
            
            # Test relationships
            user = User.query.first()
            if user:
                print(f"✅ User relationships working")
            
            print("✅ Database health check passed!")
            return True
            
        except Exception as e:
            print(f"❌ Health check failed: {e}")
            return False

if __name__ == "__main__":
    health_check()
```

## Migration vs. Recreate Decision Matrix

| Scenario | Use Migrations | Use Recreate |
|----------|---------------|--------------|
| Development with test data | Optional | ✅ Recommended |
| Development with important data | ✅ Required | ❌ |
| Staging environment | ✅ Required | ❌ |
| Production environment | ✅ Required | ❌ |
| Schema experiments | ❌ | ✅ Recommended |
| Team collaboration | ✅ Required | ❌ |
| Version control needed | ✅ Required | ❌ |

## Quick Reference

### Common Commands
```bash
# Setup (one time)
flask db init

# Daily workflow
flask db migrate -m "Description"
flask db upgrade

# Troubleshooting
flask db current
flask db history
flask db downgrade

# Emergency
python backup_db.py backup
flask db downgrade
```

### File Structure After Setup
```
warehouse/
├── migrations/
│   ├── alembic.ini
│   ├── env.py
│   ├── script.py.mako
│   └── versions/
│       ├── 001_initial_migration.py
│       ├── 002_add_email_to_user.py
│       └── 003_add_address_table.py
├── data_warehouse_models.py
├── api.py
└── manage_db.py
```

This migration guide provides everything you need to implement production-ready database schema management with Flask-Migrate!
